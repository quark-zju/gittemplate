# Generate macros.rs

import os
from typing import Dict

from pylib.macros import StatefulMacroRules
from textwrap import dedent


def main():
    s = StatefulMacroRules(
        macro_name="impl_object",
        macro_attribute="/// Derive `ObjectProtocol` methods.\n#[doc(hidden)]",
        state_name_pats={
            "attr_names": "$(($attr:ident $attr_str:expr))*",
            "name": "$impl_name:ident",
            "impl_body": "$($impl_body:tt)*",
            "impl_meta": "$($impl_meta:meta)*",
            "impl_object_protocol": "$($impl_object_protocol:tt)*",
            "impl_deref_object": "$($impl_deref_object:tt)*",
        },
        state_initials={
            "impl_deref_object": """\
            fn deref_object(&self, name: &str) -> crate::Result<Option<crate::objects::protocol::Object>> {
                crate::objects::auto_deref::default_deref_object(self, name)
            }
            """
        },
    )
    s.rule(
        input_pat="impl ObjectProtocol for $_name:tt { $($impl_object_protocol:tt)* } ...",
        state_appends={"impl_object_protocol": "$($impl_object_protocol)*"},
        comment="ObjectProtocol impl block.",
    )
    s.rule(
        input_pat="$(#[$impl_meta:meta])* impl $name:ident { ... }",
        state_appends={"name": "$name", "impl_meta": "$($impl_meta)*"},
        comment="Main impl block.",
    )
    for name in [
        "is_true",
        "deref_object",
        "is_eq",
        "to_serde_value",
        "to_ast_fmt_string",
    ]:
        state_replaces = {}
        if name == "deref_object":
            state_replaces["impl_deref_object"] = ""
        s.rule(
            input_pat=f"fn {name} $fn_args:tt -> $fn_res:ty {{ $($fn_body:tt)* }} ...",
            state_appends={
                "impl_object_protocol": f"fn {name} $fn_args -> $fn_res {{ $($fn_body)* }}",
            },
            state_replaces=state_replaces,
            comment=f"Special case: {name} (ObjectProtocol).",
        )
    for raw in ["if", "try"]:
        s.rule(
            input_pat=f"$(#[$fn_meta:meta])* $fn_vis:vis fn r#{raw} $fn_args:tt -> $fn_res:ty {{ $($fn_body:tt)* }} ...",
            state_appends={
                "impl_body": f"$(#[$fn_meta])* $fn_vis fn r#{raw} $fn_args -> $fn_res {{ $($fn_body)* }}",
                "attr_names": f'(r#{raw} "{raw}")',
            },
            comment=f"Special case: r#{raw} function (raw ident).",
        )
    s.rule(
        input_pat="$(#[$fn_meta:meta])* $fn_vis:vis fn $fn_name:ident $fn_args:tt -> $fn_res:ty { $($fn_body:tt)* } ...",
        state_appends={
            "impl_body": "$(#[$fn_meta])* $fn_vis fn $fn_name $fn_args -> $fn_res { $($fn_body)* }",
            "attr_names": "($fn_name stringify!($fn_name))",
        },
        comment="Method or property.",
    )
    code = s.conclude(
        dedent(
            """\
            $(#[$impl_meta])*
            impl $impl_name {
                $($impl_body)*
            }
            impl crate::objects::protocol::ObjectProtocol for $impl_name {
                fn get_attr(&self, name: &str) -> crate::Result<crate::objects::protocol::Attribute> {
                    #[allow(unused_imports)]
                    use crate::objects::protocol::{Attribute, ToAttribute};
                    match name {
                        $(
                        $attr_str => Ok(ToAttribute::to_attribute(self, &Self::$attr, $attr_str)?),
                        )*
                        #[allow(unreachable_patterns)]
                        _ => Ok(Attribute::Missing)
                    }
                }
                fn static_list_attrs() -> &'static [&'static str] {
                    &[$( $attr_str, )*]
                }
                fn list_attrs(&self) -> &'static [&'static str] {
                    Self::static_list_attrs()
                }
                fn as_any(&self) -> Option<&dyn std::any::Any> {
                    Some(self as &dyn std::any::Any)
                }
                fn type_name(&self) -> std::borrow::Cow<'static, str> {
                    Self::static_type_name()
                }
                fn static_type_name() -> std::borrow::Cow<'static, str> {
                    let name = stringify!($impl_name);
                    let name = name.strip_suffix("Object").unwrap_or(name);
                    name.into()
                }
                $($impl_object_protocol)*
                $($impl_deref_object)*
            }
            impl crate::objects::protocol::convert::IntoObject for $impl_name {
                fn into_object(self) -> crate::objects::protocol::Object {
                    crate::objects::protocol::ObjectProtocol::to_object(self)
                }
            }
            """
        )
    )
    text = "// Generated by macros_gen.py\n\n%s\n" % code.strip()
    data = text.encode("utf-8")
    with open("macros.rs", "rb") as f:
        if f.read() == data:
            return
    with open("macros.rs", "wb") as f:
        f.write(data)


if __name__ == "__main__":
    os.chdir(os.path.dirname(__file__))
    main()
